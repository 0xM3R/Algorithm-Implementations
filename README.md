#Algorithm Implementations

(note: there is a backstory on my motivation for starting this at the bottom of this README)


Purpose
----------
We see tons of interesting projects that are actively contributed to here on Github. Seriously, it's very powerful.

Unfortunately, I haven't really spotted (a popular and language agnostic) one where people used the power of Git to share, discover, discuss and improve algorithm implementations! 

***Send me a pull request, and I will add any implementation of any algorithm you have.***

Conventions
-----------

+ Language doesn't matter. Just make sure you're implementing an algorithm.
+ Submissions should follow this directory structure
	
		Algorithm_Name/Language_Name/username/filename.extension
		Algorithm_Name/Language_Name/username/filename_unittest.extension
    
+ It is preferred that you prepend or append your files with your Github username or some identifier to avoid overwriting others' implementations. `git blame` is cool, and has many more appropriate applications, but in this context I'd rather pull a flat list of files and be able to check out everyone's contributions that way than have to look through the revisions.

+ Each algorithm should have its corresppnding unit test cases (as directory structure suggested above) which covers the corner cases, happy/unhappy paths.
	Advantage of doing so is to assert that every thing is covered and algorithm is not broken between code change.
	It also helps newbies to have a quick look at the unit test cases and understand the basic usecase of the algorithm.

+ Documentation inside the code is recommended. This helps others in understanding the code base.

+ Have fun!

Resources
---------
We should also keep a curated list of resources dealing with algorithms.

####Introductory Books
+ [Introduction to Algorithms](http://www.amazon.com/Introduction-Algorithms-Second-Edition-Thomas/dp/0262032937) (CLRS)
+ [Algorithms](http://www.amazon.com/Algorithms-Sanjoy-Dasgupta/dp/0073523402) (Dasgupta, Papadimitriou, and Vazirani)
+ [The Algorithm Design Manual](http://www.amazon.com/Algorithm-Design-Manual-Steve-Skiena/dp/0387948600) (Steven Skiena)
+ [Algorithms, 4th Edition](http://algs4.cs.princeton.edu/home/) (Robert Sedgewick, Kevin Wayne)


####Sites
+ [LiteratePrograms](http://en.literateprograms.org/LiteratePrograms:Welcome) (TONS of code samples in various problem domains)
+ [UVa Online Judge](http://uva.onlinejudge.org) (TONS of problems to solve, automatic judging)
+ [Stony Brook Algorithm Repository](http://www.cs.sunysb.edu/~algorith/)
+ [The Archive of Interesting Code](http://www.keithschwarz.com/interesting/)
+ [ACM Collected Algorithms(CALGO)](http://calgo.acm.org)

####Online Classes
+ [Algorithms Part I - Coursera](https://www.coursera.org/course/algs4partI)
+ [Algorithms Part II - Coursera](https://www.coursera.org/course/algs4partII)
+ [Algorithms: Design and Analysis, Part 1 - Coursera](https://www.coursera.org/course/algo)
+ [Algorithms: Design and Analysis, Part 2 - Coursera](https://www.coursera.org/course/algo2)

Thanks to everyone in the HN thread who've been suggesting links. I'm going to try and get some sleep, but I will add a thank you note with everyone's screenname by their recommendation in the morning.

Backstory
---------
I have been "***coding***" since I was about 12, and have been teaching myself **software engineering** principles through solving problems in various languages through practice, freelance work and my own projects.

But, you see, it wasn't until a couple of years ago in high school when I started to truly see the light about how languages are merely *tools*; I basically realized what is common sense to me now - to truly be able to call one's self a *proficient* programmer, one must go beyond simple syntax slinging and be capable of efficiently solving a much wider subset of problems within computer programming than the *average* programmer.

Of course, this was merely one of the initial revelations that led to the revelation that ultimately led to this repository. 


When I decided to become a Computer Science major, I took the initiative to research actual **Computer Science** topics, outside of class, as I've always been more of a self-learner.

 Lo and behold, CS and practical software engineering turned out to be two entirely different things. 

I won't go into my whole journey up til this point in this README, but tl;dr:

**There are many problem domains which are simply closed off to the programmer who stagnates in his learning and never studies how to analyze algorithms and develop his own. This is objectively true.**


I also have a much greater level of respect towards my profession now, and take it very seriously. I have a relatively rigorous base education roadmap that I've laid out for myself. Even being just a core subset of skills from which I will base subsequently developed skills on, it's quite expansive and diverse. I do not plan on stagnating, ever.

